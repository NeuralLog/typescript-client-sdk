/* tslint:disable */
/* eslint-disable */
/**
 * NeuralLog API
 * API for the NeuralLog logging service
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AppendLogEntry201Response
 */
export interface AppendLogEntry201Response {
    /**
     * 
     * @type {string}
     * @memberof AppendLogEntry201Response
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppendLogEntry201Response
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppendLogEntry201Response
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface BatchAppendLogEntries201Response
 */
export interface BatchAppendLogEntries201Response {
    /**
     * 
     * @type {number}
     * @memberof BatchAppendLogEntries201Response
     */
    'count'?: number;
    /**
     * 
     * @type {Array<BatchAppendLogEntries201ResponseEntriesInner>}
     * @memberof BatchAppendLogEntries201Response
     */
    'entries'?: Array<BatchAppendLogEntries201ResponseEntriesInner>;
}
/**
 * 
 * @export
 * @interface BatchAppendLogEntries201ResponseEntriesInner
 */
export interface BatchAppendLogEntries201ResponseEntriesInner {
    /**
     * 
     * @type {string}
     * @memberof BatchAppendLogEntries201ResponseEntriesInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatchAppendLogEntries201ResponseEntriesInner
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface BatchAppendLogEntriesRequest
 */
export interface BatchAppendLogEntriesRequest {
    /**
     * 
     * @type {Array<LogEntry>}
     * @memberof BatchAppendLogEntriesRequest
     */
    'entries': Array<LogEntry>;
}
/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * Log ID
     * @type {string}
     * @memberof Log
     */
    'id'?: string;
    /**
     * Log name
     * @type {string}
     * @memberof Log
     */
    'name': string;
    /**
     * Log description
     * @type {string}
     * @memberof Log
     */
    'description'?: string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof Log
     */
    'tenantId': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof Log
     */
    'createdAt'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof Log
     */
    'updatedAt'?: string;
    /**
     * Number of days to retain log entries
     * @type {number}
     * @memberof Log
     */
    'retentionDays'?: number;
    /**
     * Whether encryption is enabled for this log
     * @type {boolean}
     * @memberof Log
     */
    'encryptionEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * Log entry ID
     * @type {string}
     * @memberof LogEntry
     */
    'id'?: string;
    /**
     * Log ID
     * @type {string}
     * @memberof LogEntry
     */
    'logId': string;
    /**
     * Timestamp
     * @type {string}
     * @memberof LogEntry
     */
    'timestamp'?: string;
    /**
     * Log entry data
     * @type {object}
     * @memberof LogEntry
     */
    'data': object;
    /**
     * Search tokens
     * @type {Array<string>}
     * @memberof LogEntry
     */
    'searchTokens'?: Array<string>;
    /**
     * 
     * @type {LogEntryEncryptionInfo}
     * @memberof LogEntry
     */
    'encryptionInfo'?: LogEntryEncryptionInfo;
}
/**
 * 
 * @export
 * @interface LogEntryEncryptionInfo
 */
export interface LogEntryEncryptionInfo {
    /**
     * Encryption version
     * @type {string}
     * @memberof LogEntryEncryptionInfo
     */
    'version'?: string;
    /**
     * Encryption algorithm
     * @type {string}
     * @memberof LogEntryEncryptionInfo
     */
    'algorithm'?: string;
}
/**
 * 
 * @export
 * @interface LogSearchOptions
 */
export interface LogSearchOptions {
    /**
     * Search query
     * @type {string}
     * @memberof LogSearchOptions
     */
    'query'?: string;
    /**
     * Search tokens
     * @type {Array<string>}
     * @memberof LogSearchOptions
     */
    'searchTokens'?: Array<string>;
    /**
     * Start time for search range
     * @type {string}
     * @memberof LogSearchOptions
     */
    'startTime'?: string;
    /**
     * End time for search range
     * @type {string}
     * @memberof LogSearchOptions
     */
    'endTime'?: string;
    /**
     * Maximum number of entries to return
     * @type {number}
     * @memberof LogSearchOptions
     */
    'limit'?: number;
    /**
     * Offset for pagination
     * @type {number}
     * @memberof LogSearchOptions
     */
    'offset'?: number;
    /**
     * Sort order
     * @type {string}
     * @memberof LogSearchOptions
     */
    'sortOrder'?: LogSearchOptionsSortOrderEnum;
}

export const LogSearchOptionsSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type LogSearchOptionsSortOrderEnum = typeof LogSearchOptionsSortOrderEnum[keyof typeof LogSearchOptionsSortOrderEnum];

/**
 * 
 * @export
 * @interface LogUpdate
 */
export interface LogUpdate {
    /**
     * Log description
     * @type {string}
     * @memberof LogUpdate
     */
    'description'?: string;
    /**
     * Number of days to retain log entries
     * @type {number}
     * @memberof LogUpdate
     */
    'retentionDays'?: number;
    /**
     * Whether encryption is enabled for this log
     * @type {boolean}
     * @memberof LogUpdate
     */
    'encryptionEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedLogEntries
 */
export interface PaginatedLogEntries {
    /**
     * 
     * @type {Array<LogEntry>}
     * @memberof PaginatedLogEntries
     */
    'entries'?: Array<LogEntry>;
    /**
     * Total number of entries
     * @type {number}
     * @memberof PaginatedLogEntries
     */
    'total'?: number;
    /**
     * Maximum number of entries returned
     * @type {number}
     * @memberof PaginatedLogEntries
     */
    'limit'?: number;
    /**
     * Offset for pagination
     * @type {number}
     * @memberof PaginatedLogEntries
     */
    'offset'?: number;
    /**
     * Whether there are more entries
     * @type {boolean}
     * @memberof PaginatedLogEntries
     */
    'hasMore'?: boolean;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Append a log entry
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogEntry} logEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendLogEntry: async (logName: string, xTenantId: string, logEntry: LogEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('appendLogEntry', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('appendLogEntry', 'xTenantId', xTenantId)
            // verify required parameter 'logEntry' is not null or undefined
            assertParamExists('appendLogEntry', 'logEntry', logEntry)
            const localVarPath = `/logs/{logName}/entries`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Batch append log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {BatchAppendLogEntriesRequest} batchAppendLogEntriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAppendLogEntries: async (logName: string, xTenantId: string, batchAppendLogEntriesRequest: BatchAppendLogEntriesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('batchAppendLogEntries', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('batchAppendLogEntries', 'xTenantId', xTenantId)
            // verify required parameter 'batchAppendLogEntriesRequest' is not null or undefined
            assertParamExists('batchAppendLogEntries', 'batchAppendLogEntriesRequest', batchAppendLogEntriesRequest)
            const localVarPath = `/logs/{logName}/entries/batch`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchAppendLogEntriesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new log
         * @param {string} xTenantId Tenant ID
         * @param {Log} log 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLog: async (xTenantId: string, log: Log, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('createLog', 'xTenantId', xTenantId)
            // verify required parameter 'log' is not null or undefined
            assertParamExists('createLog', 'log', log)
            const localVarPath = `/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(log, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a log
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLog: async (logName: string, xTenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('deleteLog', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('deleteLog', 'xTenantId', xTenantId)
            const localVarPath = `/logs/{logName}`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a log by name
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog: async (logName: string, xTenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('getLog', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('getLog', 'xTenantId', xTenantId)
            const localVarPath = `/logs/{logName}`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {number} [limit] Maximum number of entries to return
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries: async (logName: string, xTenantId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('getLogEntries', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('getLogEntries', 'xTenantId', xTenantId)
            const localVarPath = `/logs/{logName}/entries`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all logs
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs: async (xTenantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('getLogs', 'xTenantId', xTenantId)
            const localVarPath = `/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogSearchOptions} logSearchOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogEntries: async (logName: string, xTenantId: string, logSearchOptions: LogSearchOptions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('searchLogEntries', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('searchLogEntries', 'xTenantId', xTenantId)
            // verify required parameter 'logSearchOptions' is not null or undefined
            assertParamExists('searchLogEntries', 'logSearchOptions', logSearchOptions)
            const localVarPath = `/logs/{logName}/search`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logSearchOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a log
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogUpdate} logUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLog: async (logName: string, xTenantId: string, logUpdate: LogUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'logName' is not null or undefined
            assertParamExists('updateLog', 'logName', logName)
            // verify required parameter 'xTenantId' is not null or undefined
            assertParamExists('updateLog', 'xTenantId', xTenantId)
            // verify required parameter 'logUpdate' is not null or undefined
            assertParamExists('updateLog', 'logUpdate', logUpdate)
            const localVarPath = `/logs/{logName}`
                .replace(`{${"logName"}}`, encodeURIComponent(String(logName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xTenantId != null) {
                localVarHeaderParameter['x-tenant-id'] = String(xTenantId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Append a log entry
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogEntry} logEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appendLogEntry(logName: string, xTenantId: string, logEntry: LogEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppendLogEntry201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appendLogEntry(logName, xTenantId, logEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.appendLogEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Batch append log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {BatchAppendLogEntriesRequest} batchAppendLogEntriesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchAppendLogEntries(logName: string, xTenantId: string, batchAppendLogEntriesRequest: BatchAppendLogEntriesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchAppendLogEntries201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchAppendLogEntries(logName, xTenantId, batchAppendLogEntriesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.batchAppendLogEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new log
         * @param {string} xTenantId Tenant ID
         * @param {Log} log 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLog(xTenantId: string, log: Log, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLog(xTenantId, log, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a log
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLog(logName: string, xTenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLog(logName, xTenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a log by name
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLog(logName: string, xTenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLog(logName, xTenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {number} [limit] Maximum number of entries to return
         * @param {number} [offset] Offset for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogEntries(logName: string, xTenantId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLogEntries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogEntries(logName, xTenantId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLogEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all logs
         * @param {string} xTenantId Tenant ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogs(xTenantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Log>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogs(xTenantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search log entries
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogSearchOptions} logSearchOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLogEntries(logName: string, xTenantId: string, logSearchOptions: LogSearchOptions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedLogEntries>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLogEntries(logName, xTenantId, logSearchOptions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.searchLogEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a log
         * @param {string} logName Log name
         * @param {string} xTenantId Tenant ID
         * @param {LogUpdate} logUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLog(logName: string, xTenantId: string, logUpdate: LogUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLog(logName, xTenantId, logUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Append a log entry
         * @param {DefaultApiAppendLogEntryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appendLogEntry(requestParameters: DefaultApiAppendLogEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AppendLogEntry201Response> {
            return localVarFp.appendLogEntry(requestParameters.logName, requestParameters.xTenantId, requestParameters.logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Batch append log entries
         * @param {DefaultApiBatchAppendLogEntriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchAppendLogEntries(requestParameters: DefaultApiBatchAppendLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchAppendLogEntries201Response> {
            return localVarFp.batchAppendLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.batchAppendLogEntriesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new log
         * @param {DefaultApiCreateLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLog(requestParameters: DefaultApiCreateLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log> {
            return localVarFp.createLog(requestParameters.xTenantId, requestParameters.log, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a log
         * @param {DefaultApiDeleteLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLog(requestParameters: DefaultApiDeleteLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteLog(requestParameters.logName, requestParameters.xTenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a log by name
         * @param {DefaultApiGetLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLog(requestParameters: DefaultApiGetLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log> {
            return localVarFp.getLog(requestParameters.logName, requestParameters.xTenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get log entries
         * @param {DefaultApiGetLogEntriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries(requestParameters: DefaultApiGetLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries> {
            return localVarFp.getLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all logs
         * @param {DefaultApiGetLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogs(requestParameters: DefaultApiGetLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Log>> {
            return localVarFp.getLogs(requestParameters.xTenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search log entries
         * @param {DefaultApiSearchLogEntriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogEntries(requestParameters: DefaultApiSearchLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries> {
            return localVarFp.searchLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.logSearchOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a log
         * @param {DefaultApiUpdateLogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLog(requestParameters: DefaultApiUpdateLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log> {
            return localVarFp.updateLog(requestParameters.logName, requestParameters.xTenantId, requestParameters.logUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Append a log entry
     * @param {DefaultApiAppendLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    appendLogEntry(requestParameters: DefaultApiAppendLogEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<AppendLogEntry201Response>;

    /**
     * 
     * @summary Batch append log entries
     * @param {DefaultApiBatchAppendLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    batchAppendLogEntries(requestParameters: DefaultApiBatchAppendLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<BatchAppendLogEntries201Response>;

    /**
     * 
     * @summary Create a new log
     * @param {DefaultApiCreateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    createLog(requestParameters: DefaultApiCreateLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log>;

    /**
     * 
     * @summary Delete a log
     * @param {DefaultApiDeleteLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    deleteLog(requestParameters: DefaultApiDeleteLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a log by name
     * @param {DefaultApiGetLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getLog(requestParameters: DefaultApiGetLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log>;

    /**
     * 
     * @summary Get log entries
     * @param {DefaultApiGetLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getLogEntries(requestParameters: DefaultApiGetLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries>;

    /**
     * 
     * @summary Get all logs
     * @param {DefaultApiGetLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    getLogs(requestParameters: DefaultApiGetLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Log>>;

    /**
     * 
     * @summary Search log entries
     * @param {DefaultApiSearchLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    searchLogEntries(requestParameters: DefaultApiSearchLogEntriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedLogEntries>;

    /**
     * 
     * @summary Update a log
     * @param {DefaultApiUpdateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    updateLog(requestParameters: DefaultApiUpdateLogRequest, options?: RawAxiosRequestConfig): AxiosPromise<Log>;

}

/**
 * Request parameters for appendLogEntry operation in DefaultApi.
 * @export
 * @interface DefaultApiAppendLogEntryRequest
 */
export interface DefaultApiAppendLogEntryRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiAppendLogEntry
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiAppendLogEntry
     */
    readonly xTenantId: string

    /**
     * 
     * @type {LogEntry}
     * @memberof DefaultApiAppendLogEntry
     */
    readonly logEntry: LogEntry
}

/**
 * Request parameters for batchAppendLogEntries operation in DefaultApi.
 * @export
 * @interface DefaultApiBatchAppendLogEntriesRequest
 */
export interface DefaultApiBatchAppendLogEntriesRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiBatchAppendLogEntries
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiBatchAppendLogEntries
     */
    readonly xTenantId: string

    /**
     * 
     * @type {BatchAppendLogEntriesRequest}
     * @memberof DefaultApiBatchAppendLogEntries
     */
    readonly batchAppendLogEntriesRequest: BatchAppendLogEntriesRequest
}

/**
 * Request parameters for createLog operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateLogRequest
 */
export interface DefaultApiCreateLogRequest {
    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiCreateLog
     */
    readonly xTenantId: string

    /**
     * 
     * @type {Log}
     * @memberof DefaultApiCreateLog
     */
    readonly log: Log
}

/**
 * Request parameters for deleteLog operation in DefaultApi.
 * @export
 * @interface DefaultApiDeleteLogRequest
 */
export interface DefaultApiDeleteLogRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiDeleteLog
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiDeleteLog
     */
    readonly xTenantId: string
}

/**
 * Request parameters for getLog operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLogRequest
 */
export interface DefaultApiGetLogRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiGetLog
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiGetLog
     */
    readonly xTenantId: string
}

/**
 * Request parameters for getLogEntries operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLogEntriesRequest
 */
export interface DefaultApiGetLogEntriesRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiGetLogEntries
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiGetLogEntries
     */
    readonly xTenantId: string

    /**
     * Maximum number of entries to return
     * @type {number}
     * @memberof DefaultApiGetLogEntries
     */
    readonly limit?: number

    /**
     * Offset for pagination
     * @type {number}
     * @memberof DefaultApiGetLogEntries
     */
    readonly offset?: number
}

/**
 * Request parameters for getLogs operation in DefaultApi.
 * @export
 * @interface DefaultApiGetLogsRequest
 */
export interface DefaultApiGetLogsRequest {
    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiGetLogs
     */
    readonly xTenantId: string
}

/**
 * Request parameters for searchLogEntries operation in DefaultApi.
 * @export
 * @interface DefaultApiSearchLogEntriesRequest
 */
export interface DefaultApiSearchLogEntriesRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiSearchLogEntries
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiSearchLogEntries
     */
    readonly xTenantId: string

    /**
     * 
     * @type {LogSearchOptions}
     * @memberof DefaultApiSearchLogEntries
     */
    readonly logSearchOptions: LogSearchOptions
}

/**
 * Request parameters for updateLog operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdateLogRequest
 */
export interface DefaultApiUpdateLogRequest {
    /**
     * Log name
     * @type {string}
     * @memberof DefaultApiUpdateLog
     */
    readonly logName: string

    /**
     * Tenant ID
     * @type {string}
     * @memberof DefaultApiUpdateLog
     */
    readonly xTenantId: string

    /**
     * 
     * @type {LogUpdate}
     * @memberof DefaultApiUpdateLog
     */
    readonly logUpdate: LogUpdate
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Append a log entry
     * @param {DefaultApiAppendLogEntryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public appendLogEntry(requestParameters: DefaultApiAppendLogEntryRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).appendLogEntry(requestParameters.logName, requestParameters.xTenantId, requestParameters.logEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Batch append log entries
     * @param {DefaultApiBatchAppendLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public batchAppendLogEntries(requestParameters: DefaultApiBatchAppendLogEntriesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).batchAppendLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.batchAppendLogEntriesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new log
     * @param {DefaultApiCreateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createLog(requestParameters: DefaultApiCreateLogRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createLog(requestParameters.xTenantId, requestParameters.log, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a log
     * @param {DefaultApiDeleteLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteLog(requestParameters: DefaultApiDeleteLogRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteLog(requestParameters.logName, requestParameters.xTenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a log by name
     * @param {DefaultApiGetLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLog(requestParameters: DefaultApiGetLogRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLog(requestParameters.logName, requestParameters.xTenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get log entries
     * @param {DefaultApiGetLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLogEntries(requestParameters: DefaultApiGetLogEntriesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all logs
     * @param {DefaultApiGetLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getLogs(requestParameters: DefaultApiGetLogsRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getLogs(requestParameters.xTenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search log entries
     * @param {DefaultApiSearchLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchLogEntries(requestParameters: DefaultApiSearchLogEntriesRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchLogEntries(requestParameters.logName, requestParameters.xTenantId, requestParameters.logSearchOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a log
     * @param {DefaultApiUpdateLogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateLog(requestParameters: DefaultApiUpdateLogRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateLog(requestParameters.logName, requestParameters.xTenantId, requestParameters.logUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



