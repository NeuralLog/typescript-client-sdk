/* tslint:disable */
/* eslint-disable */
/**
 * NeuralLog Auth API
 * API for authentication and authorization in NeuralLog
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminPromotionRequest
 */
export interface AdminPromotionRequest {
    /**
     * Request ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'id': string;
    /**
     * Candidate user ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'candidate_id': string;
    /**
     * Candidate username
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'candidate_name': string;
    /**
     * Requester user ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'requester_id': string;
    /**
     * Requester username
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'requester_name': string;
    /**
     * Request timestamp
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'timestamp': string;
    /**
     * Request status
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'status': AdminPromotionRequestStatusEnum;
    /**
     * Threshold (number of approvals required)
     * @type {number}
     * @memberof AdminPromotionRequest
     */
    'threshold': number;
    /**
     * Number of approvals received
     * @type {number}
     * @memberof AdminPromotionRequest
     */
    'approvals': number;
}

export const AdminPromotionRequestStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type AdminPromotionRequestStatusEnum = typeof AdminPromotionRequestStatusEnum[keyof typeof AdminPromotionRequestStatusEnum];

/**
 * 
 * @export
 * @interface AdminShare
 */
export interface AdminShare {
    /**
     * Admin share ID
     * @type {string}
     * @memberof AdminShare
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof AdminShare
     */
    'user_id': string;
    /**
     * Encrypted share
     * @type {string}
     * @memberof AdminShare
     */
    'encrypted_share': string;
    /**
     * Creation date
     * @type {string}
     * @memberof AdminShare
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AdminShareRequest
 */
export interface AdminShareRequest {
    /**
     * Candidate user ID
     * @type {string}
     * @memberof AdminShareRequest
     */
    'candidate_id': string;
    /**
     * Encrypted share data
     * @type {string}
     * @memberof AdminShareRequest
     */
    'encrypted_share': string;
    /**
     * Public key used for encryption
     * @type {string}
     * @memberof AdminShareRequest
     */
    'public_key': string;
    /**
     * Threshold (number of shares required)
     * @type {number}
     * @memberof AdminShareRequest
     */
    'threshold': number;
}
/**
 * 
 * @export
 * @interface AdminShares
 */
export interface AdminShares {
    /**
     * Admin shares
     * @type {Array<AdminShare>}
     * @memberof AdminShares
     */
    'shares': Array<AdminShare>;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKey
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof ApiKey
     */
    'userId': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ApiKey
     */
    'tenantId': string;
    /**
     * API key name
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * API key scopes
     * @type {Array<string>}
     * @memberof ApiKey
     */
    'scopes': Array<string>;
    /**
     * Verification hash for the API key
     * @type {string}
     * @memberof ApiKey
     */
    'verificationHash': string;
    /**
     * When the API key was created
     * @type {string}
     * @memberof ApiKey
     */
    'createdAt': string;
    /**
     * When the API key expires
     * @type {string}
     * @memberof ApiKey
     */
    'expiresAt': string;
    /**
     * Whether the API key is revoked
     * @type {boolean}
     * @memberof ApiKey
     */
    'revoked': boolean;
    /**
     * When the API key was revoked
     * @type {string}
     * @memberof ApiKey
     */
    'revokedAt'?: string;
    /**
     * Last used timestamp
     * @type {string}
     * @memberof ApiKey
     */
    'lastUsedAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyChallenge
 */
export interface ApiKeyChallenge {
    /**
     * Challenge string
     * @type {string}
     * @memberof ApiKeyChallenge
     */
    'challenge': string;
    /**
     * Expiration time in seconds
     * @type {number}
     * @memberof ApiKeyChallenge
     */
    'expiresIn': number;
}
/**
 * 
 * @export
 * @interface ApiKeyChallengeVerification
 */
export interface ApiKeyChallengeVerification {
    /**
     * Whether the challenge response is valid
     * @type {boolean}
     * @memberof ApiKeyChallengeVerification
     */
    'valid': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof ApiKeyChallengeVerification
     */
    'userId'?: string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ApiKeyChallengeVerification
     */
    'tenantId'?: string;
    /**
     * Scopes
     * @type {Array<string>}
     * @memberof ApiKeyChallengeVerification
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiKeyInfo
 */
export interface ApiKeyInfo {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'id': string;
    /**
     * API key name
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'name': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'created_at': string;
    /**
     * Expiration timestamp (if applicable)
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'expires_at'?: string;
    /**
     * Whether the API key is revoked
     * @type {boolean}
     * @memberof ApiKeyInfo
     */
    'revoked': boolean;
}
/**
 * 
 * @export
 * @interface ApiKeyPermission
 */
export interface ApiKeyPermission {
    /**
     * Action (e.g., \'read\', \'write\')
     * @type {string}
     * @memberof ApiKeyPermission
     */
    'action': string;
    /**
     * Resource (e.g., \'logs\', \'logs/my-log\')
     * @type {string}
     * @memberof ApiKeyPermission
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface ApiKeysChallengePostRequest
 */
export interface ApiKeysChallengePostRequest {
    /**
     * API key
     * @type {string}
     * @memberof ApiKeysChallengePostRequest
     */
    'apiKey': string;
}
/**
 * 
 * @export
 * @interface ApiKeysPost201Response
 */
export interface ApiKeysPost201Response {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKeysPost201Response
     */
    'id': string;
    /**
     * API key (only returned once)
     * @type {string}
     * @memberof ApiKeysPost201Response
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface ApiKeysVerifyChallengePostRequest
 */
export interface ApiKeysVerifyChallengePostRequest {
    /**
     * API key
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'apiKey': string;
    /**
     * Challenge
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'challenge': string;
    /**
     * Challenge response
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'response': string;
}
/**
 * 
 * @export
 * @interface AuthExchangeTokenPostRequest
 */
export interface AuthExchangeTokenPostRequest {
    /**
     * Resource to access
     * @type {string}
     * @memberof AuthExchangeTokenPostRequest
     */
    'resource': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof AuthExchangeTokenPostRequest
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface AuthLoginPost401Response
 */
export interface AuthLoginPost401Response {
    /**
     * Error message
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'error'?: string;
    /**
     * Error code
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginPostRequest
 */
export interface AuthLoginPostRequest {
    /**
     * User email
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthVerifyResourceTokenPostRequest
 */
export interface AuthVerifyResourceTokenPostRequest {
    /**
     * Resource token
     * @type {string}
     * @memberof AuthVerifyResourceTokenPostRequest
     */
    'token': string;
    /**
     * Resource to access
     * @type {string}
     * @memberof AuthVerifyResourceTokenPostRequest
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * API key name
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'name': string;
    /**
     * Expiration time in days (optional)
     * @type {number}
     * @memberof CreateApiKeyRequest
     */
    'expires_in'?: number;
    /**
     * Permissions for this API key
     * @type {Array<ApiKeyPermission>}
     * @memberof CreateApiKeyRequest
     */
    'permissions'?: Array<ApiKeyPermission>;
}
/**
 * 
 * @export
 * @interface EncryptedKEK
 */
export interface EncryptedKEK {
    /**
     * Whether the KEK is encrypted
     * @type {boolean}
     * @memberof EncryptedKEK
     */
    'encrypted': boolean;
    /**
     * Encryption algorithm
     * @type {string}
     * @memberof EncryptedKEK
     */
    'algorithm': string;
    /**
     * Initialization vector
     * @type {string}
     * @memberof EncryptedKEK
     */
    'iv': string;
    /**
     * Encrypted KEK data
     * @type {string}
     * @memberof EncryptedKEK
     */
    'data': string;
    /**
     * KEK version
     * @type {string}
     * @memberof EncryptedKEK
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface KEKBlob
 */
export interface KEKBlob {
    /**
     * User ID
     * @type {string}
     * @memberof KEKBlob
     */
    'userId': string;
    /**
     * KEK version ID
     * @type {string}
     * @memberof KEKBlob
     */
    'kekVersionId': string;
    /**
     * Encrypted blob
     * @type {string}
     * @memberof KEKBlob
     */
    'encryptedBlob': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof KEKBlob
     */
    'tenantId': string;
    /**
     * Creation date
     * @type {string}
     * @memberof KEKBlob
     */
    'createdAt': string;
    /**
     * Update date
     * @type {string}
     * @memberof KEKBlob
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface KEKBlobs
 */
export interface KEKBlobs {
    /**
     * KEK blobs
     * @type {Array<KEKBlob>}
     * @memberof KEKBlobs
     */
    'blobs': Array<KEKBlob>;
}
/**
 * 
 * @export
 * @interface KEKVersion
 */
export interface KEKVersion {
    /**
     * KEK version ID
     * @type {string}
     * @memberof KEKVersion
     */
    'id': string;
    /**
     * Creation date
     * @type {string}
     * @memberof KEKVersion
     */
    'createdAt': string;
    /**
     * Created by user ID
     * @type {string}
     * @memberof KEKVersion
     */
    'createdBy': string;
    /**
     * Status
     * @type {string}
     * @memberof KEKVersion
     */
    'status': KEKVersionStatusEnum;
    /**
     * Reason for creation
     * @type {string}
     * @memberof KEKVersion
     */
    'reason': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof KEKVersion
     */
    'tenantId': string;
}

export const KEKVersionStatusEnum = {
    Active: 'active',
    DecryptOnly: 'decrypt-only',
    Deprecated: 'deprecated'
} as const;

export type KEKVersionStatusEnum = typeof KEKVersionStatusEnum[keyof typeof KEKVersionStatusEnum];

/**
 * 
 * @export
 * @interface KEKVersions
 */
export interface KEKVersions {
    /**
     * KEK versions
     * @type {Array<KEKVersion>}
     * @memberof KEKVersions
     */
    'versions': Array<KEKVersion>;
}
/**
 * 
 * @export
 * @interface KeysList
 */
export interface KeysList {
    /**
     * API keys
     * @type {Array<ApiKey>}
     * @memberof KeysList
     */
    'api_keys': Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Authentication token
     * @type {string}
     * @memberof Login
     */
    'token': string;
    /**
     * User ID
     * @type {string}
     * @memberof Login
     */
    'user_id': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof Login
     */
    'tenant_id': string;
    /**
     * 
     * @type {UserProfile}
     * @memberof Login
     */
    'user'?: UserProfile;
}
/**
 * 
 * @export
 * @interface PermissionCheck
 */
export interface PermissionCheck {
    /**
     * Whether the user has permission
     * @type {boolean}
     * @memberof PermissionCheck
     */
    'allowed': boolean;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * User ID
     * @type {string}
     * @memberof PublicKey
     */
    'userId': string;
    /**
     * Public key data
     * @type {string}
     * @memberof PublicKey
     */
    'publicKey': string;
    /**
     * Purpose of the public key (e.g., \'admin-promotion\')
     * @type {string}
     * @memberof PublicKey
     */
    'purpose': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof PublicKey
     */
    'tenantId': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof PublicKey
     */
    'createdAt': string;
    /**
     * Update timestamp
     * @type {string}
     * @memberof PublicKey
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface ResourceTokenVerificationResult
 */
export interface ResourceTokenVerificationResult {
    /**
     * Whether the token is valid
     * @type {boolean}
     * @memberof ResourceTokenVerificationResult
     */
    'valid': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'userId': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'tenantId': string;
    /**
     * Resource
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * Role ID
     * @type {string}
     * @memberof Role
     */
    'id': string;
    /**
     * Role name
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Role description
     * @type {string}
     * @memberof Role
     */
    'description'?: string;
    /**
     * Role permissions
     * @type {Array<string>}
     * @memberof Role
     */
    'permissions': Array<string>;
    /**
     * Roles this role inherits from
     * @type {Array<string>}
     * @memberof Role
     */
    'inherits'?: Array<string>;
    /**
     * Tenant ID
     * @type {string}
     * @memberof Role
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface SerializedSecretShare
 */
export interface SerializedSecretShare {
    /**
     * The x-coordinate of the share
     * @type {number}
     * @memberof SerializedSecretShare
     */
    'x': number;
    /**
     * The y-coordinate of the share (the actual share value) as a Base64 string
     * @type {string}
     * @memberof SerializedSecretShare
     */
    'y': string;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * Tenant ID
     * @type {string}
     * @memberof Tenant
     */
    'tenantId': string;
    /**
     * Admin user ID
     * @type {string}
     * @memberof Tenant
     */
    'adminUserId': string;
}
/**
 * 
 * @export
 * @interface TokenExchangeResult
 */
export interface TokenExchangeResult {
    /**
     * The exchanged token
     * @type {string}
     * @memberof TokenExchangeResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TokenValidationResult
 */
export interface TokenValidationResult {
    /**
     * Whether the token is valid
     * @type {boolean}
     * @memberof TokenValidationResult
     */
    'valid': boolean;
    /**
     * 
     * @type {UserProfile}
     * @memberof TokenValidationResult
     */
    'user'?: UserProfile;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * User email
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User name
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof User
     */
    'tenantId': string;
    /**
     * Whether the user is an admin
     * @type {boolean}
     * @memberof User
     */
    'isAdmin'?: boolean;
    /**
     * Creation date
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * User ID
     * @type {string}
     * @memberof UserProfile
     */
    'id': string;
    /**
     * Email
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof UserProfile
     */
    'tenantId': string;
    /**
     * Name
     * @type {string}
     * @memberof UserProfile
     */
    'name'?: string;
    /**
     * Username (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'username'?: string;
    /**
     * First name (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'first_name'?: string;
    /**
     * Last name (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'last_name'?: string;
    /**
     * User roles (optional)
     * @type {Array<string>}
     * @memberof UserProfile
     */
    'roles'?: Array<string>;
}

/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {ApiKeysChallengePostRequest} apiKeysChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysChallengePost: async (apiKeysChallengePostRequest: ApiKeysChallengePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeysChallengePostRequest' is not null or undefined
            assertParamExists('apiKeysChallengePost', 'apiKeysChallengePostRequest', apiKeysChallengePostRequest)
            const localVarPath = `/api-keys/challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeysChallengePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeysIdDelete', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeysIdGet', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {CreateApiKeyRequest} createApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysPost: async (createApiKeyRequest: CreateApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApiKeyRequest' is not null or undefined
            assertParamExists('apiKeysPost', 'createApiKeyRequest', createApiKeyRequest)
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {ApiKeysVerifyChallengePostRequest} apiKeysVerifyChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysVerifyChallengePost: async (apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeysVerifyChallengePostRequest' is not null or undefined
            assertParamExists('apiKeysVerifyChallengePost', 'apiKeysVerifyChallengePostRequest', apiKeysVerifyChallengePostRequest)
            const localVarPath = `/api-keys/verify-challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeysVerifyChallengePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {ApiKeysChallengePostRequest} apiKeysChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysChallengePost(apiKeysChallengePostRequest: ApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysChallengePost(apiKeysChallengePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysChallengePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {CreateApiKeyRequest} createApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysPost(createApiKeyRequest: CreateApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeysPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysPost(createApiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {ApiKeysVerifyChallengePostRequest} apiKeysVerifyChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysVerifyChallengePost(apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyChallengeVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysVerifyChallengePost(apiKeysVerifyChallengePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysVerifyChallengePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallenge> {
            return localVarFp.apiKeysChallengePost(requestParameters.apiKeysChallengePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<KeysList> {
            return localVarFp.apiKeysGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeysIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKey> {
            return localVarFp.apiKeysIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeysPost201Response> {
            return localVarFp.apiKeysPost(requestParameters.createApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallengeVerification> {
            return localVarFp.apiKeysVerifyChallengePost(requestParameters.apiKeysVerifyChallengePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - interface
 * @export
 * @interface APIKeysApi
 */
export interface APIKeysApiInterface {
    /**
     * Get a challenge for API key authentication
     * @summary Get API key challenge
     * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallenge>;

    /**
     * Get all API keys for the current user
     * @summary Get API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<KeysList>;

    /**
     * Revoke an API key
     * @summary Revoke API key
     * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get an API key by ID
     * @summary Get API key
     * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKey>;

    /**
     * Create a new API key
     * @summary Create API key
     * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeysPost201Response>;

    /**
     * Verify a challenge response for API key authentication
     * @summary Verify API key challenge
     * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallengeVerification>;

}

/**
 * Request parameters for apiKeysChallengePost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysChallengePostRequest
 */
export interface APIKeysApiApiKeysChallengePostRequest {
    /**
     * 
     * @type {ApiKeysChallengePostRequest}
     * @memberof APIKeysApiApiKeysChallengePost
     */
    readonly apiKeysChallengePostRequest: ApiKeysChallengePostRequest
}

/**
 * Request parameters for apiKeysIdDelete operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysIdDeleteRequest
 */
export interface APIKeysApiApiKeysIdDeleteRequest {
    /**
     * API key ID
     * @type {string}
     * @memberof APIKeysApiApiKeysIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for apiKeysIdGet operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysIdGetRequest
 */
export interface APIKeysApiApiKeysIdGetRequest {
    /**
     * API key ID
     * @type {string}
     * @memberof APIKeysApiApiKeysIdGet
     */
    readonly id: string
}

/**
 * Request parameters for apiKeysPost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysPostRequest
 */
export interface APIKeysApiApiKeysPostRequest {
    /**
     * 
     * @type {CreateApiKeyRequest}
     * @memberof APIKeysApiApiKeysPost
     */
    readonly createApiKeyRequest: CreateApiKeyRequest
}

/**
 * Request parameters for apiKeysVerifyChallengePost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysVerifyChallengePostRequest
 */
export interface APIKeysApiApiKeysVerifyChallengePostRequest {
    /**
     * 
     * @type {ApiKeysVerifyChallengePostRequest}
     * @memberof APIKeysApiApiKeysVerifyChallengePost
     */
    readonly apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest
}

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI implements APIKeysApiInterface {
    /**
     * Get a challenge for API key authentication
     * @summary Get API key challenge
     * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysChallengePost(requestParameters.apiKeysChallengePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all API keys for the current user
     * @summary Get API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysGet(options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an API key
     * @summary Revoke API key
     * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an API key by ID
     * @summary Get API key
     * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key
     * @summary Create API key
     * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysPost(requestParameters.createApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a challenge response for API key authentication
     * @summary Verify API key challenge
     * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysVerifyChallengePost(requestParameters.apiKeysVerifyChallengePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthExchangeTokenPostRequest} authExchangeTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authExchangeTokenPost: async (authExchangeTokenPostRequest: AuthExchangeTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authExchangeTokenPostRequest' is not null or undefined
            assertParamExists('authExchangeTokenPost', 'authExchangeTokenPostRequest', authExchangeTokenPostRequest)
            const localVarPath = `/auth/exchange-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authExchangeTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authLoginPostRequest: AuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginPostRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authLoginPostRequest', authLoginPostRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateTokenPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validate-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthVerifyResourceTokenPostRequest} authVerifyResourceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyResourceTokenPost: async (authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyResourceTokenPostRequest' is not null or undefined
            assertParamExists('authVerifyResourceTokenPost', 'authVerifyResourceTokenPostRequest', authVerifyResourceTokenPostRequest)
            const localVarPath = `/auth/verify-resource-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyResourceTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthExchangeTokenPostRequest} authExchangeTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authExchangeTokenPost(authExchangeTokenPostRequest: AuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenExchangeResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authExchangeTokenPost(authExchangeTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authExchangeTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authValidateTokenPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authValidateTokenPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authValidateTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthVerifyResourceTokenPostRequest} authVerifyResourceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyResourceTokenPost(authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceTokenVerificationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyResourceTokenPost(authVerifyResourceTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyResourceTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenExchangeResult> {
            return localVarFp.authExchangeTokenPost(requestParameters.authExchangeTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login> {
            return localVarFp.authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<TokenValidationResult> {
            return localVarFp.authValidateTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceTokenVerificationResult> {
            return localVarFp.authVerifyResourceTokenPost(requestParameters.authVerifyResourceTokenPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Exchange an authentication token for a resource-specific token
     * @summary Exchange token for resource token
     * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenExchangeResult>;

    /**
     * Authenticate a user with email and password
     * @summary Login with email and password
     * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login>;

    /**
     * Logout the current user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Validate an authentication token
     * @summary Validate token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authValidateTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<TokenValidationResult>;

    /**
     * Verify a resource-specific token
     * @summary Verify resource token
     * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceTokenVerificationResult>;

}

/**
 * Request parameters for authExchangeTokenPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthExchangeTokenPostRequest
 */
export interface AuthApiAuthExchangeTokenPostRequest {
    /**
     * 
     * @type {AuthExchangeTokenPostRequest}
     * @memberof AuthApiAuthExchangeTokenPost
     */
    readonly authExchangeTokenPostRequest: AuthExchangeTokenPostRequest
}

/**
 * Request parameters for authLoginPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthLoginPostRequest
 */
export interface AuthApiAuthLoginPostRequest {
    /**
     * 
     * @type {AuthLoginPostRequest}
     * @memberof AuthApiAuthLoginPost
     */
    readonly authLoginPostRequest: AuthLoginPostRequest
}

/**
 * Request parameters for authVerifyResourceTokenPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthVerifyResourceTokenPostRequest
 */
export interface AuthApiAuthVerifyResourceTokenPostRequest {
    /**
     * 
     * @type {AuthVerifyResourceTokenPostRequest}
     * @memberof AuthApiAuthVerifyResourceTokenPost
     */
    readonly authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Exchange an authentication token for a resource-specific token
     * @summary Exchange token for resource token
     * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authExchangeTokenPost(requestParameters.authExchangeTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user with email and password
     * @summary Login with email and password
     * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout the current user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an authentication token
     * @summary Validate token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authValidateTokenPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authValidateTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a resource-specific token
     * @summary Verify resource token
     * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyResourceTokenPost(requestParameters.authVerifyResourceTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



