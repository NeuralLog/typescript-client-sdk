/* tslint:disable */
/* eslint-disable */
/**
 * NeuralLog Auth API
 * API for authentication and authorization in NeuralLog
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AdminPromotionRequest
 */
export interface AdminPromotionRequest {
    /**
     * Request ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'id': string;
    /**
     * Candidate user ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'candidate_id': string;
    /**
     * Candidate username
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'candidate_name': string;
    /**
     * Requester user ID
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'requester_id': string;
    /**
     * Requester username
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'requester_name': string;
    /**
     * Request timestamp
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'timestamp': string;
    /**
     * Request status
     * @type {string}
     * @memberof AdminPromotionRequest
     */
    'status': AdminPromotionRequestStatusEnum;
    /**
     * Threshold (number of approvals required)
     * @type {number}
     * @memberof AdminPromotionRequest
     */
    'threshold': number;
    /**
     * Number of approvals received
     * @type {number}
     * @memberof AdminPromotionRequest
     */
    'approvals': number;
}

export const AdminPromotionRequestStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type AdminPromotionRequestStatusEnum = typeof AdminPromotionRequestStatusEnum[keyof typeof AdminPromotionRequestStatusEnum];

/**
 * 
 * @export
 * @interface AdminShare
 */
export interface AdminShare {
    /**
     * Admin share ID
     * @type {string}
     * @memberof AdminShare
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof AdminShare
     */
    'user_id': string;
    /**
     * Encrypted share
     * @type {string}
     * @memberof AdminShare
     */
    'encrypted_share': string;
    /**
     * Creation date
     * @type {string}
     * @memberof AdminShare
     */
    'created_at': string;
}
/**
 * 
 * @export
 * @interface AdminShareRequest
 */
export interface AdminShareRequest {
    /**
     * Candidate user ID
     * @type {string}
     * @memberof AdminShareRequest
     */
    'candidate_id': string;
    /**
     * Encrypted share data
     * @type {string}
     * @memberof AdminShareRequest
     */
    'encrypted_share': string;
    /**
     * Public key used for encryption
     * @type {string}
     * @memberof AdminShareRequest
     */
    'public_key': string;
    /**
     * Threshold (number of shares required)
     * @type {number}
     * @memberof AdminShareRequest
     */
    'threshold': number;
}
/**
 * 
 * @export
 * @interface AdminShares
 */
export interface AdminShares {
    /**
     * Admin shares
     * @type {Array<AdminShare>}
     * @memberof AdminShares
     */
    'shares': Array<AdminShare>;
}
/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKey
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof ApiKey
     */
    'userId': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ApiKey
     */
    'tenantId': string;
    /**
     * API key name
     * @type {string}
     * @memberof ApiKey
     */
    'name': string;
    /**
     * API key scopes
     * @type {Array<string>}
     * @memberof ApiKey
     */
    'scopes': Array<string>;
    /**
     * Verification hash for the API key
     * @type {string}
     * @memberof ApiKey
     */
    'verificationHash': string;
    /**
     * When the API key was created
     * @type {string}
     * @memberof ApiKey
     */
    'createdAt': string;
    /**
     * When the API key expires
     * @type {string}
     * @memberof ApiKey
     */
    'expiresAt': string;
    /**
     * Whether the API key is revoked
     * @type {boolean}
     * @memberof ApiKey
     */
    'revoked': boolean;
    /**
     * When the API key was revoked
     * @type {string}
     * @memberof ApiKey
     */
    'revokedAt'?: string;
    /**
     * Last used timestamp
     * @type {string}
     * @memberof ApiKey
     */
    'lastUsedAt'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyChallenge
 */
export interface ApiKeyChallenge {
    /**
     * Challenge string
     * @type {string}
     * @memberof ApiKeyChallenge
     */
    'challenge': string;
    /**
     * Expiration time in seconds
     * @type {number}
     * @memberof ApiKeyChallenge
     */
    'expiresIn': number;
}
/**
 * 
 * @export
 * @interface ApiKeyChallengeVerification
 */
export interface ApiKeyChallengeVerification {
    /**
     * Whether the challenge response is valid
     * @type {boolean}
     * @memberof ApiKeyChallengeVerification
     */
    'valid': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof ApiKeyChallengeVerification
     */
    'userId'?: string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ApiKeyChallengeVerification
     */
    'tenantId'?: string;
    /**
     * Scopes
     * @type {Array<string>}
     * @memberof ApiKeyChallengeVerification
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ApiKeyInfo
 */
export interface ApiKeyInfo {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'id': string;
    /**
     * API key name
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'name': string;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'created_at': string;
    /**
     * Expiration timestamp (if applicable)
     * @type {string}
     * @memberof ApiKeyInfo
     */
    'expires_at'?: string;
    /**
     * Whether the API key is revoked
     * @type {boolean}
     * @memberof ApiKeyInfo
     */
    'revoked': boolean;
}
/**
 * 
 * @export
 * @interface ApiKeyPermission
 */
export interface ApiKeyPermission {
    /**
     * Action (e.g., \'read\', \'write\')
     * @type {string}
     * @memberof ApiKeyPermission
     */
    'action': string;
    /**
     * Resource (e.g., \'logs\', \'logs/my-log\')
     * @type {string}
     * @memberof ApiKeyPermission
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface ApiKeysChallengePostRequest
 */
export interface ApiKeysChallengePostRequest {
    /**
     * API key
     * @type {string}
     * @memberof ApiKeysChallengePostRequest
     */
    'apiKey': string;
}
/**
 * 
 * @export
 * @interface ApiKeysPost201Response
 */
export interface ApiKeysPost201Response {
    /**
     * API key ID
     * @type {string}
     * @memberof ApiKeysPost201Response
     */
    'id': string;
    /**
     * API key (only returned once)
     * @type {string}
     * @memberof ApiKeysPost201Response
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface ApiKeysVerifyChallengePostRequest
 */
export interface ApiKeysVerifyChallengePostRequest {
    /**
     * API key
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'apiKey': string;
    /**
     * Challenge
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'challenge': string;
    /**
     * Challenge response
     * @type {string}
     * @memberof ApiKeysVerifyChallengePostRequest
     */
    'response': string;
}
/**
 * 
 * @export
 * @interface AuthCheckPostRequest
 */
export interface AuthCheckPostRequest {
    /**
     * User identifier
     * @type {string}
     * @memberof AuthCheckPostRequest
     */
    'user': string;
    /**
     * Relation (e.g., \'read\', \'write\')
     * @type {string}
     * @memberof AuthCheckPostRequest
     */
    'relation': string;
    /**
     * Object identifier
     * @type {string}
     * @memberof AuthCheckPostRequest
     */
    'object': string;
    /**
     * Contextual tuples for the check
     * @type {Array<AuthCheckPostRequestContextualTuplesInner>}
     * @memberof AuthCheckPostRequest
     */
    'contextualTuples'?: Array<AuthCheckPostRequestContextualTuplesInner>;
}
/**
 * 
 * @export
 * @interface AuthCheckPostRequestContextualTuplesInner
 */
export interface AuthCheckPostRequestContextualTuplesInner {
    /**
     * User identifier
     * @type {string}
     * @memberof AuthCheckPostRequestContextualTuplesInner
     */
    'user': string;
    /**
     * Relation
     * @type {string}
     * @memberof AuthCheckPostRequestContextualTuplesInner
     */
    'relation': string;
    /**
     * Object identifier
     * @type {string}
     * @memberof AuthCheckPostRequestContextualTuplesInner
     */
    'object': string;
}
/**
 * 
 * @export
 * @interface AuthExchangeTokenPostRequest
 */
export interface AuthExchangeTokenPostRequest {
    /**
     * Resource to access
     * @type {string}
     * @memberof AuthExchangeTokenPostRequest
     */
    'resource': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof AuthExchangeTokenPostRequest
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface AuthLoginPost401Response
 */
export interface AuthLoginPost401Response {
    /**
     * Error message
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'error'?: string;
    /**
     * Error code
     * @type {string}
     * @memberof AuthLoginPost401Response
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface AuthLoginPostRequest
 */
export interface AuthLoginPostRequest {
    /**
     * User email
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'email': string;
    /**
     * User password
     * @type {string}
     * @memberof AuthLoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthVerifyResourceTokenPostRequest
 */
export interface AuthVerifyResourceTokenPostRequest {
    /**
     * Resource token
     * @type {string}
     * @memberof AuthVerifyResourceTokenPostRequest
     */
    'token': string;
    /**
     * Resource to access
     * @type {string}
     * @memberof AuthVerifyResourceTokenPostRequest
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface CompleteKEKRecoveryRequest
 */
export interface CompleteKEKRecoveryRequest {
    /**
     * The recovered KEK (encrypted with the user\'s public key)
     * @type {string}
     * @memberof CompleteKEKRecoveryRequest
     */
    'recoveredKEK': string;
    /**
     * 
     * @type {CompleteKEKRecoveryRequestNewKEKVersion}
     * @memberof CompleteKEKRecoveryRequest
     */
    'newKEKVersion': CompleteKEKRecoveryRequestNewKEKVersion;
}
/**
 * Information about the new KEK version
 * @export
 * @interface CompleteKEKRecoveryRequestNewKEKVersion
 */
export interface CompleteKEKRecoveryRequestNewKEKVersion {
    /**
     * New KEK version ID
     * @type {string}
     * @memberof CompleteKEKRecoveryRequestNewKEKVersion
     */
    'id': string;
    /**
     * Reason for the new KEK version
     * @type {string}
     * @memberof CompleteKEKRecoveryRequestNewKEKVersion
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * API key name
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    'name': string;
    /**
     * Expiration time in days (optional)
     * @type {number}
     * @memberof CreateApiKeyRequest
     */
    'expires_in'?: number;
    /**
     * Permissions for this API key
     * @type {Array<ApiKeyPermission>}
     * @memberof CreateApiKeyRequest
     */
    'permissions'?: Array<ApiKeyPermission>;
}
/**
 * 
 * @export
 * @interface EncryptedKEK
 */
export interface EncryptedKEK {
    /**
     * Whether the KEK is encrypted
     * @type {boolean}
     * @memberof EncryptedKEK
     */
    'encrypted': boolean;
    /**
     * Encryption algorithm
     * @type {string}
     * @memberof EncryptedKEK
     */
    'algorithm': string;
    /**
     * Initialization vector
     * @type {string}
     * @memberof EncryptedKEK
     */
    'iv': string;
    /**
     * Encrypted KEK data
     * @type {string}
     * @memberof EncryptedKEK
     */
    'data': string;
    /**
     * KEK version
     * @type {string}
     * @memberof EncryptedKEK
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface InitiateKEKRecoveryRequest
 */
export interface InitiateKEKRecoveryRequest {
    /**
     * KEK version ID to recover
     * @type {string}
     * @memberof InitiateKEKRecoveryRequest
     */
    'versionId': string;
    /**
     * Number of shares required for recovery
     * @type {number}
     * @memberof InitiateKEKRecoveryRequest
     */
    'threshold': number;
    /**
     * Reason for recovery
     * @type {string}
     * @memberof InitiateKEKRecoveryRequest
     */
    'reason': string;
    /**
     * Expiration time in seconds
     * @type {number}
     * @memberof InitiateKEKRecoveryRequest
     */
    'expiresIn'?: number;
}
/**
 * 
 * @export
 * @interface KEKBlob
 */
export interface KEKBlob {
    /**
     * User ID
     * @type {string}
     * @memberof KEKBlob
     */
    'userId': string;
    /**
     * KEK version ID
     * @type {string}
     * @memberof KEKBlob
     */
    'kekVersionId': string;
    /**
     * Encrypted blob
     * @type {string}
     * @memberof KEKBlob
     */
    'encryptedBlob': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof KEKBlob
     */
    'tenantId': string;
    /**
     * Creation date
     * @type {string}
     * @memberof KEKBlob
     */
    'createdAt': string;
    /**
     * Update date
     * @type {string}
     * @memberof KEKBlob
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface KEKBlobs
 */
export interface KEKBlobs {
    /**
     * KEK blobs
     * @type {Array<KEKBlob>}
     * @memberof KEKBlobs
     */
    'blobs': Array<KEKBlob>;
}
/**
 * 
 * @export
 * @interface KEKVersion
 */
export interface KEKVersion {
    /**
     * KEK version ID
     * @type {string}
     * @memberof KEKVersion
     */
    'id': string;
    /**
     * Creation date
     * @type {string}
     * @memberof KEKVersion
     */
    'createdAt': string;
    /**
     * Created by user ID
     * @type {string}
     * @memberof KEKVersion
     */
    'createdBy': string;
    /**
     * Status
     * @type {string}
     * @memberof KEKVersion
     */
    'status': KEKVersionStatusEnum;
    /**
     * Reason for creation
     * @type {string}
     * @memberof KEKVersion
     */
    'reason': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof KEKVersion
     */
    'tenantId': string;
}

export const KEKVersionStatusEnum = {
    Active: 'active',
    DecryptOnly: 'decrypt-only',
    Deprecated: 'deprecated'
} as const;

export type KEKVersionStatusEnum = typeof KEKVersionStatusEnum[keyof typeof KEKVersionStatusEnum];

/**
 * 
 * @export
 * @interface KEKVersions
 */
export interface KEKVersions {
    /**
     * KEK versions
     * @type {Array<KEKVersion>}
     * @memberof KEKVersions
     */
    'versions': Array<KEKVersion>;
}
/**
 * 
 * @export
 * @interface KekRecoveryResult
 */
export interface KekRecoveryResult {
    /**
     * Recovery session ID
     * @type {string}
     * @memberof KekRecoveryResult
     */
    'sessionId': string;
    /**
     * Original KEK version ID
     * @type {string}
     * @memberof KekRecoveryResult
     */
    'versionId': string;
    /**
     * New KEK version ID
     * @type {string}
     * @memberof KekRecoveryResult
     */
    'newVersionId': string;
    /**
     * Status of the recovery
     * @type {string}
     * @memberof KekRecoveryResult
     */
    'status': KekRecoveryResultStatusEnum;
    /**
     * Completion timestamp
     * @type {string}
     * @memberof KekRecoveryResult
     */
    'completedAt': string;
}

export const KekRecoveryResultStatusEnum = {
    Completed: 'completed'
} as const;

export type KekRecoveryResultStatusEnum = typeof KekRecoveryResultStatusEnum[keyof typeof KekRecoveryResultStatusEnum];

/**
 * 
 * @export
 * @interface KekRecoverySession
 */
export interface KekRecoverySession {
    /**
     * Recovery session ID
     * @type {string}
     * @memberof KekRecoverySession
     */
    'id': string;
    /**
     * KEK version ID
     * @type {string}
     * @memberof KekRecoverySession
     */
    'versionId': string;
    /**
     * User ID of the initiator
     * @type {string}
     * @memberof KekRecoverySession
     */
    'initiatedBy': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof KekRecoverySession
     */
    'tenantId': string;
    /**
     * Number of shares required for recovery
     * @type {number}
     * @memberof KekRecoverySession
     */
    'threshold': number;
    /**
     * Reason for recovery
     * @type {string}
     * @memberof KekRecoverySession
     */
    'reason': string;
    /**
     * Status of the recovery session
     * @type {string}
     * @memberof KekRecoverySession
     */
    'status': KekRecoverySessionStatusEnum;
    /**
     * Submitted shares
     * @type {Array<KekRecoverySessionSharesInner>}
     * @memberof KekRecoverySession
     */
    'shares': Array<KekRecoverySessionSharesInner>;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof KekRecoverySession
     */
    'createdAt': string;
    /**
     * Expiration timestamp
     * @type {string}
     * @memberof KekRecoverySession
     */
    'expiresAt': string;
}

export const KekRecoverySessionStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Expired: 'expired',
    Cancelled: 'cancelled'
} as const;

export type KekRecoverySessionStatusEnum = typeof KekRecoverySessionStatusEnum[keyof typeof KekRecoverySessionStatusEnum];

/**
 * 
 * @export
 * @interface KekRecoverySessionSharesInner
 */
export interface KekRecoverySessionSharesInner {
    /**
     * User ID who submitted the share
     * @type {string}
     * @memberof KekRecoverySessionSharesInner
     */
    'userId'?: string;
    /**
     * Timestamp when the share was submitted
     * @type {string}
     * @memberof KekRecoverySessionSharesInner
     */
    'submittedAt'?: string;
}
/**
 * 
 * @export
 * @interface KeysList
 */
export interface KeysList {
    /**
     * API keys
     * @type {Array<ApiKey>}
     * @memberof KeysList
     */
    'api_keys': Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Authentication token
     * @type {string}
     * @memberof Login
     */
    'token': string;
    /**
     * User ID
     * @type {string}
     * @memberof Login
     */
    'user_id': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof Login
     */
    'tenant_id': string;
    /**
     * 
     * @type {UserProfile}
     * @memberof Login
     */
    'user'?: UserProfile;
}
/**
 * 
 * @export
 * @interface PermissionCheck
 */
export interface PermissionCheck {
    /**
     * Whether the user has permission
     * @type {boolean}
     * @memberof PermissionCheck
     */
    'allowed': boolean;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * Public key ID
     * @type {string}
     * @memberof PublicKey
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof PublicKey
     */
    'userId': string;
    /**
     * Public key data (Base64-encoded)
     * @type {string}
     * @memberof PublicKey
     */
    'publicKey': string;
    /**
     * Purpose of the public key
     * @type {string}
     * @memberof PublicKey
     */
    'purpose': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof PublicKey
     */
    'tenantId': string;
    /**
     * Additional metadata
     * @type {object}
     * @memberof PublicKey
     */
    'metadata'?: object;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof PublicKey
     */
    'createdAt': string;
    /**
     * Update timestamp
     * @type {string}
     * @memberof PublicKey
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface RegisterPublicKeyRequest
 */
export interface RegisterPublicKeyRequest {
    /**
     * Public key data (Base64-encoded)
     * @type {string}
     * @memberof RegisterPublicKeyRequest
     */
    'publicKey': string;
    /**
     * Purpose of the public key (e.g., \'admin-promotion\')
     * @type {string}
     * @memberof RegisterPublicKeyRequest
     */
    'purpose': string;
    /**
     * Additional metadata
     * @type {object}
     * @memberof RegisterPublicKeyRequest
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface ResourceTokenVerificationResult
 */
export interface ResourceTokenVerificationResult {
    /**
     * Whether the token is valid
     * @type {boolean}
     * @memberof ResourceTokenVerificationResult
     */
    'valid': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'userId': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'tenantId': string;
    /**
     * Resource
     * @type {string}
     * @memberof ResourceTokenVerificationResult
     */
    'resource': string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * Role ID
     * @type {string}
     * @memberof Role
     */
    'id': string;
    /**
     * Role name
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * Role description
     * @type {string}
     * @memberof Role
     */
    'description'?: string;
    /**
     * Role permissions
     * @type {Array<string>}
     * @memberof Role
     */
    'permissions': Array<string>;
    /**
     * Roles this role inherits from
     * @type {Array<string>}
     * @memberof Role
     */
    'inherits'?: Array<string>;
    /**
     * Tenant ID
     * @type {string}
     * @memberof Role
     */
    'tenantId': string;
}
/**
 * 
 * @export
 * @interface SerializedSecretShare
 */
export interface SerializedSecretShare {
    /**
     * The x-coordinate of the share
     * @type {number}
     * @memberof SerializedSecretShare
     */
    'x': number;
    /**
     * The y-coordinate of the share (the actual share value) as a Base64 string
     * @type {string}
     * @memberof SerializedSecretShare
     */
    'y': string;
}
/**
 * 
 * @export
 * @interface SubmitRecoveryShareRequest
 */
export interface SubmitRecoveryShareRequest {
    /**
     * 
     * @type {SerializedSecretShare}
     * @memberof SubmitRecoveryShareRequest
     */
    'share': SerializedSecretShare;
    /**
     * User ID for whom the share is encrypted
     * @type {string}
     * @memberof SubmitRecoveryShareRequest
     */
    'encryptedFor': string;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * Tenant ID
     * @type {string}
     * @memberof Tenant
     */
    'tenantId': string;
    /**
     * Admin user ID
     * @type {string}
     * @memberof Tenant
     */
    'adminUserId': string;
}
/**
 * 
 * @export
 * @interface TokenExchangeResult
 */
export interface TokenExchangeResult {
    /**
     * The exchanged token
     * @type {string}
     * @memberof TokenExchangeResult
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TokenValidationResult
 */
export interface TokenValidationResult {
    /**
     * Whether the token is valid
     * @type {boolean}
     * @memberof TokenValidationResult
     */
    'valid': boolean;
    /**
     * 
     * @type {UserProfile}
     * @memberof TokenValidationResult
     */
    'user'?: UserProfile;
}
/**
 * 
 * @export
 * @interface UpdatePublicKeyRequest
 */
export interface UpdatePublicKeyRequest {
    /**
     * Public key data (Base64-encoded)
     * @type {string}
     * @memberof UpdatePublicKeyRequest
     */
    'publicKey': string;
    /**
     * Additional metadata
     * @type {object}
     * @memberof UpdatePublicKeyRequest
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User ID
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * User email
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * User name
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof User
     */
    'tenantId': string;
    /**
     * Whether the user is an admin
     * @type {boolean}
     * @memberof User
     */
    'isAdmin'?: boolean;
    /**
     * Creation date
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * User ID
     * @type {string}
     * @memberof UserProfile
     */
    'id': string;
    /**
     * Email
     * @type {string}
     * @memberof UserProfile
     */
    'email': string;
    /**
     * Tenant ID
     * @type {string}
     * @memberof UserProfile
     */
    'tenantId': string;
    /**
     * Name
     * @type {string}
     * @memberof UserProfile
     */
    'name'?: string;
    /**
     * Username (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'username'?: string;
    /**
     * First name (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'first_name'?: string;
    /**
     * Last name (optional)
     * @type {string}
     * @memberof UserProfile
     */
    'last_name'?: string;
    /**
     * User roles (optional)
     * @type {Array<string>}
     * @memberof UserProfile
     */
    'roles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VerifyPublicKeyRequest
 */
export interface VerifyPublicKeyRequest {
    /**
     * Public key ID
     * @type {string}
     * @memberof VerifyPublicKeyRequest
     */
    'keyId': string;
    /**
     * Challenge to sign
     * @type {string}
     * @memberof VerifyPublicKeyRequest
     */
    'challenge': string;
    /**
     * Signature of the challenge
     * @type {string}
     * @memberof VerifyPublicKeyRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface VerifyPublicKeyResponse
 */
export interface VerifyPublicKeyResponse {
    /**
     * Whether the public key was verified
     * @type {boolean}
     * @memberof VerifyPublicKeyResponse
     */
    'verified': boolean;
    /**
     * User ID
     * @type {string}
     * @memberof VerifyPublicKeyResponse
     */
    'userId': string;
    /**
     * Public key ID
     * @type {string}
     * @memberof VerifyPublicKeyResponse
     */
    'keyId': string;
}

/**
 * APIKeysApi - axios parameter creator
 * @export
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {ApiKeysChallengePostRequest} apiKeysChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysChallengePost: async (apiKeysChallengePostRequest: ApiKeysChallengePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeysChallengePostRequest' is not null or undefined
            assertParamExists('apiKeysChallengePost', 'apiKeysChallengePostRequest', apiKeysChallengePostRequest)
            const localVarPath = `/api-keys/challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeysChallengePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeysIdDelete', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeysIdGet', 'id', id)
            const localVarPath = `/api-keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {CreateApiKeyRequest} createApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysPost: async (createApiKeyRequest: CreateApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createApiKeyRequest' is not null or undefined
            assertParamExists('apiKeysPost', 'createApiKeyRequest', createApiKeyRequest)
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {ApiKeysVerifyChallengePostRequest} apiKeysVerifyChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysVerifyChallengePost: async (apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeysVerifyChallengePostRequest' is not null or undefined
            assertParamExists('apiKeysVerifyChallengePost', 'apiKeysVerifyChallengePostRequest', apiKeysVerifyChallengePostRequest)
            const localVarPath = `/api-keys/verify-challenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeysVerifyChallengePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 * @export
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {ApiKeysChallengePostRequest} apiKeysChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysChallengePost(apiKeysChallengePostRequest: ApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyChallenge>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysChallengePost(apiKeysChallengePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysChallengePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeysList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysIdDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {string} id API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysIdGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {CreateApiKeyRequest} createApiKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysPost(createApiKeyRequest: CreateApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeysPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysPost(createApiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {ApiKeysVerifyChallengePostRequest} apiKeysVerifyChallengePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeysVerifyChallengePost(apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyChallengeVerification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeysVerifyChallengePost(apiKeysVerifyChallengePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.apiKeysVerifyChallengePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeysApi - factory interface
 * @export
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Get a challenge for API key authentication
         * @summary Get API key challenge
         * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallenge> {
            return localVarFp.apiKeysChallengePost(requestParameters.apiKeysChallengePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all API keys for the current user
         * @summary Get API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<KeysList> {
            return localVarFp.apiKeysGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an API key
         * @summary Revoke API key
         * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiKeysIdDelete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an API key by ID
         * @summary Get API key
         * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKey> {
            return localVarFp.apiKeysIdGet(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @summary Create API key
         * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeysPost201Response> {
            return localVarFp.apiKeysPost(requestParameters.createApiKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a challenge response for API key authentication
         * @summary Verify API key challenge
         * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallengeVerification> {
            return localVarFp.apiKeysVerifyChallengePost(requestParameters.apiKeysVerifyChallengePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - interface
 * @export
 * @interface APIKeysApi
 */
export interface APIKeysApiInterface {
    /**
     * Get a challenge for API key authentication
     * @summary Get API key challenge
     * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallenge>;

    /**
     * Get all API keys for the current user
     * @summary Get API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<KeysList>;

    /**
     * Revoke an API key
     * @summary Revoke API key
     * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get an API key by ID
     * @summary Get API key
     * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKey>;

    /**
     * Create a new API key
     * @summary Create API key
     * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeysPost201Response>;

    /**
     * Verify a challenge response for API key authentication
     * @summary Verify API key challenge
     * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApiInterface
     */
    apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyChallengeVerification>;

}

/**
 * Request parameters for apiKeysChallengePost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysChallengePostRequest
 */
export interface APIKeysApiApiKeysChallengePostRequest {
    /**
     * 
     * @type {ApiKeysChallengePostRequest}
     * @memberof APIKeysApiApiKeysChallengePost
     */
    readonly apiKeysChallengePostRequest: ApiKeysChallengePostRequest
}

/**
 * Request parameters for apiKeysIdDelete operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysIdDeleteRequest
 */
export interface APIKeysApiApiKeysIdDeleteRequest {
    /**
     * API key ID
     * @type {string}
     * @memberof APIKeysApiApiKeysIdDelete
     */
    readonly id: string
}

/**
 * Request parameters for apiKeysIdGet operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysIdGetRequest
 */
export interface APIKeysApiApiKeysIdGetRequest {
    /**
     * API key ID
     * @type {string}
     * @memberof APIKeysApiApiKeysIdGet
     */
    readonly id: string
}

/**
 * Request parameters for apiKeysPost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysPostRequest
 */
export interface APIKeysApiApiKeysPostRequest {
    /**
     * 
     * @type {CreateApiKeyRequest}
     * @memberof APIKeysApiApiKeysPost
     */
    readonly createApiKeyRequest: CreateApiKeyRequest
}

/**
 * Request parameters for apiKeysVerifyChallengePost operation in APIKeysApi.
 * @export
 * @interface APIKeysApiApiKeysVerifyChallengePostRequest
 */
export interface APIKeysApiApiKeysVerifyChallengePostRequest {
    /**
     * 
     * @type {ApiKeysVerifyChallengePostRequest}
     * @memberof APIKeysApiApiKeysVerifyChallengePost
     */
    readonly apiKeysVerifyChallengePostRequest: ApiKeysVerifyChallengePostRequest
}

/**
 * APIKeysApi - object-oriented interface
 * @export
 * @class APIKeysApi
 * @extends {BaseAPI}
 */
export class APIKeysApi extends BaseAPI implements APIKeysApiInterface {
    /**
     * Get a challenge for API key authentication
     * @summary Get API key challenge
     * @param {APIKeysApiApiKeysChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysChallengePost(requestParameters: APIKeysApiApiKeysChallengePostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysChallengePost(requestParameters.apiKeysChallengePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all API keys for the current user
     * @summary Get API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysGet(options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an API key
     * @summary Revoke API key
     * @param {APIKeysApiApiKeysIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysIdDelete(requestParameters: APIKeysApiApiKeysIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysIdDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an API key by ID
     * @summary Get API key
     * @param {APIKeysApiApiKeysIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysIdGet(requestParameters: APIKeysApiApiKeysIdGetRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysIdGet(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key
     * @summary Create API key
     * @param {APIKeysApiApiKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysPost(requestParameters: APIKeysApiApiKeysPostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysPost(requestParameters.createApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a challenge response for API key authentication
     * @summary Verify API key challenge
     * @param {APIKeysApiApiKeysVerifyChallengePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIKeysApi
     */
    public apiKeysVerifyChallengePost(requestParameters: APIKeysApiApiKeysVerifyChallengePostRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).apiKeysVerifyChallengePost(requestParameters.apiKeysVerifyChallengePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if a user has permission to access a resource
         * @summary Check permission
         * @param {AuthCheckPostRequest} authCheckPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckPost: async (authCheckPostRequest: AuthCheckPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authCheckPostRequest' is not null or undefined
            assertParamExists('authCheckPost', 'authCheckPostRequest', authCheckPostRequest)
            const localVarPath = `/auth/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authCheckPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthExchangeTokenPostRequest} authExchangeTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authExchangeTokenPost: async (authExchangeTokenPostRequest: AuthExchangeTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authExchangeTokenPostRequest' is not null or undefined
            assertParamExists('authExchangeTokenPost', 'authExchangeTokenPostRequest', authExchangeTokenPostRequest)
            const localVarPath = `/auth/exchange-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authExchangeTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (authLoginPostRequest: AuthLoginPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authLoginPostRequest' is not null or undefined
            assertParamExists('authLoginPost', 'authLoginPostRequest', authLoginPostRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authLoginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateTokenPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/validate-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthVerifyResourceTokenPostRequest} authVerifyResourceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyResourceTokenPost: async (authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authVerifyResourceTokenPostRequest' is not null or undefined
            assertParamExists('authVerifyResourceTokenPost', 'authVerifyResourceTokenPostRequest', authVerifyResourceTokenPostRequest)
            const localVarPath = `/auth/verify-resource-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authVerifyResourceTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if a user has permission to access a resource
         * @summary Check permission
         * @param {AuthCheckPostRequest} authCheckPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCheckPost(authCheckPostRequest: AuthCheckPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheckPost(authCheckPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authCheckPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthExchangeTokenPostRequest} authExchangeTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authExchangeTokenPost(authExchangeTokenPostRequest: AuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenExchangeResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authExchangeTokenPost(authExchangeTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authExchangeTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthLoginPostRequest} authLoginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(authLoginPostRequest: AuthLoginPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(authLoginPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authValidateTokenPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authValidateTokenPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authValidateTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthVerifyResourceTokenPostRequest} authVerifyResourceTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyResourceTokenPost(authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceTokenVerificationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyResourceTokenPost(authVerifyResourceTokenPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authVerifyResourceTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Check if a user has permission to access a resource
         * @summary Check permission
         * @param {AuthApiAuthCheckPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckPost(requestParameters: AuthApiAuthCheckPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PermissionCheck> {
            return localVarFp.authCheckPost(requestParameters.authCheckPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange an authentication token for a resource-specific token
         * @summary Exchange token for resource token
         * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenExchangeResult> {
            return localVarFp.authExchangeTokenPost(requestParameters.authExchangeTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate a user with email and password
         * @summary Login with email and password
         * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login> {
            return localVarFp.authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout the current user
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate an authentication token
         * @summary Validate token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authValidateTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<TokenValidationResult> {
            return localVarFp.authValidateTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a resource-specific token
         * @summary Verify resource token
         * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceTokenVerificationResult> {
            return localVarFp.authVerifyResourceTokenPost(requestParameters.authVerifyResourceTokenPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * Check if a user has permission to access a resource
     * @summary Check permission
     * @param {AuthApiAuthCheckPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authCheckPost(requestParameters: AuthApiAuthCheckPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PermissionCheck>;

    /**
     * Exchange an authentication token for a resource-specific token
     * @summary Exchange token for resource token
     * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenExchangeResult>;

    /**
     * Authenticate a user with email and password
     * @summary Login with email and password
     * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Login>;

    /**
     * Logout the current user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Validate an authentication token
     * @summary Validate token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authValidateTokenPost(options?: RawAxiosRequestConfig): AxiosPromise<TokenValidationResult>;

    /**
     * Verify a resource-specific token
     * @summary Verify resource token
     * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResourceTokenVerificationResult>;

}

/**
 * Request parameters for authCheckPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthCheckPostRequest
 */
export interface AuthApiAuthCheckPostRequest {
    /**
     * 
     * @type {AuthCheckPostRequest}
     * @memberof AuthApiAuthCheckPost
     */
    readonly authCheckPostRequest: AuthCheckPostRequest
}

/**
 * Request parameters for authExchangeTokenPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthExchangeTokenPostRequest
 */
export interface AuthApiAuthExchangeTokenPostRequest {
    /**
     * 
     * @type {AuthExchangeTokenPostRequest}
     * @memberof AuthApiAuthExchangeTokenPost
     */
    readonly authExchangeTokenPostRequest: AuthExchangeTokenPostRequest
}

/**
 * Request parameters for authLoginPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthLoginPostRequest
 */
export interface AuthApiAuthLoginPostRequest {
    /**
     * 
     * @type {AuthLoginPostRequest}
     * @memberof AuthApiAuthLoginPost
     */
    readonly authLoginPostRequest: AuthLoginPostRequest
}

/**
 * Request parameters for authVerifyResourceTokenPost operation in AuthApi.
 * @export
 * @interface AuthApiAuthVerifyResourceTokenPostRequest
 */
export interface AuthApiAuthVerifyResourceTokenPostRequest {
    /**
     * 
     * @type {AuthVerifyResourceTokenPostRequest}
     * @memberof AuthApiAuthVerifyResourceTokenPost
     */
    readonly authVerifyResourceTokenPostRequest: AuthVerifyResourceTokenPostRequest
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * Check if a user has permission to access a resource
     * @summary Check permission
     * @param {AuthApiAuthCheckPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCheckPost(requestParameters: AuthApiAuthCheckPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCheckPost(requestParameters.authCheckPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange an authentication token for a resource-specific token
     * @summary Exchange token for resource token
     * @param {AuthApiAuthExchangeTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authExchangeTokenPost(requestParameters: AuthApiAuthExchangeTokenPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authExchangeTokenPost(requestParameters.authExchangeTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate a user with email and password
     * @summary Login with email and password
     * @param {AuthApiAuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(requestParameters: AuthApiAuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(requestParameters.authLoginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout the current user
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate an authentication token
     * @summary Validate token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authValidateTokenPost(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authValidateTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a resource-specific token
     * @summary Verify resource token
     * @param {AuthApiAuthVerifyResourceTokenPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyResourceTokenPost(requestParameters: AuthApiAuthVerifyResourceTokenPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyResourceTokenPost(requestParameters.authVerifyResourceTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KEKApi - axios parameter creator
 * @export
 */
export const KEKApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate the recovery of a KEK version
         * @summary Initiate KEK version recovery
         * @param {InitiateKEKRecoveryRequest} initiateKEKRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoveryPost: async (initiateKEKRecoveryRequest: InitiateKEKRecoveryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initiateKEKRecoveryRequest' is not null or undefined
            assertParamExists('kekRecoveryPost', 'initiateKEKRecoveryRequest', initiateKEKRecoveryRequest)
            const localVarPath = `/kek/recovery`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initiateKEKRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete the KEK recovery process
         * @summary Complete KEK recovery
         * @param {string} sessionId Recovery session ID
         * @param {CompleteKEKRecoveryRequest} completeKEKRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdCompletePost: async (sessionId: string, completeKEKRecoveryRequest: CompleteKEKRecoveryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('kekRecoverySessionIdCompletePost', 'sessionId', sessionId)
            // verify required parameter 'completeKEKRecoveryRequest' is not null or undefined
            assertParamExists('kekRecoverySessionIdCompletePost', 'completeKEKRecoveryRequest', completeKEKRecoveryRequest)
            const localVarPath = `/kek/recovery/{sessionId}/complete`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeKEKRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a KEK recovery session
         * @summary Get KEK recovery session
         * @param {string} sessionId Recovery session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdGet: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('kekRecoverySessionIdGet', 'sessionId', sessionId)
            const localVarPath = `/kek/recovery/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a share for KEK recovery
         * @summary Submit a recovery share
         * @param {string} sessionId Recovery session ID
         * @param {SubmitRecoveryShareRequest} submitRecoveryShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdSharesPost: async (sessionId: string, submitRecoveryShareRequest: SubmitRecoveryShareRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('kekRecoverySessionIdSharesPost', 'sessionId', sessionId)
            // verify required parameter 'submitRecoveryShareRequest' is not null or undefined
            assertParamExists('kekRecoverySessionIdSharesPost', 'submitRecoveryShareRequest', submitRecoveryShareRequest)
            const localVarPath = `/kek/recovery/{sessionId}/shares`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitRecoveryShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KEKApi - functional programming interface
 * @export
 */
export const KEKApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KEKApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate the recovery of a KEK version
         * @summary Initiate KEK version recovery
         * @param {InitiateKEKRecoveryRequest} initiateKEKRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kekRecoveryPost(initiateKEKRecoveryRequest: InitiateKEKRecoveryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KekRecoverySession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kekRecoveryPost(initiateKEKRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KEKApi.kekRecoveryPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete the KEK recovery process
         * @summary Complete KEK recovery
         * @param {string} sessionId Recovery session ID
         * @param {CompleteKEKRecoveryRequest} completeKEKRecoveryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kekRecoverySessionIdCompletePost(sessionId: string, completeKEKRecoveryRequest: CompleteKEKRecoveryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KekRecoveryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kekRecoverySessionIdCompletePost(sessionId, completeKEKRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KEKApi.kekRecoverySessionIdCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about a KEK recovery session
         * @summary Get KEK recovery session
         * @param {string} sessionId Recovery session ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kekRecoverySessionIdGet(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KekRecoverySession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kekRecoverySessionIdGet(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KEKApi.kekRecoverySessionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a share for KEK recovery
         * @summary Submit a recovery share
         * @param {string} sessionId Recovery session ID
         * @param {SubmitRecoveryShareRequest} submitRecoveryShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kekRecoverySessionIdSharesPost(sessionId: string, submitRecoveryShareRequest: SubmitRecoveryShareRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KekRecoverySession>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kekRecoverySessionIdSharesPost(sessionId, submitRecoveryShareRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KEKApi.kekRecoverySessionIdSharesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KEKApi - factory interface
 * @export
 */
export const KEKApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KEKApiFp(configuration)
    return {
        /**
         * Initiate the recovery of a KEK version
         * @summary Initiate KEK version recovery
         * @param {KEKApiKekRecoveryPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoveryPost(requestParameters: KEKApiKekRecoveryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession> {
            return localVarFp.kekRecoveryPost(requestParameters.initiateKEKRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete the KEK recovery process
         * @summary Complete KEK recovery
         * @param {KEKApiKekRecoverySessionIdCompletePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdCompletePost(requestParameters: KEKApiKekRecoverySessionIdCompletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoveryResult> {
            return localVarFp.kekRecoverySessionIdCompletePost(requestParameters.sessionId, requestParameters.completeKEKRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a KEK recovery session
         * @summary Get KEK recovery session
         * @param {KEKApiKekRecoverySessionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdGet(requestParameters: KEKApiKekRecoverySessionIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession> {
            return localVarFp.kekRecoverySessionIdGet(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a share for KEK recovery
         * @summary Submit a recovery share
         * @param {KEKApiKekRecoverySessionIdSharesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kekRecoverySessionIdSharesPost(requestParameters: KEKApiKekRecoverySessionIdSharesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession> {
            return localVarFp.kekRecoverySessionIdSharesPost(requestParameters.sessionId, requestParameters.submitRecoveryShareRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KEKApi - interface
 * @export
 * @interface KEKApi
 */
export interface KEKApiInterface {
    /**
     * Initiate the recovery of a KEK version
     * @summary Initiate KEK version recovery
     * @param {KEKApiKekRecoveryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApiInterface
     */
    kekRecoveryPost(requestParameters: KEKApiKekRecoveryPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession>;

    /**
     * Complete the KEK recovery process
     * @summary Complete KEK recovery
     * @param {KEKApiKekRecoverySessionIdCompletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApiInterface
     */
    kekRecoverySessionIdCompletePost(requestParameters: KEKApiKekRecoverySessionIdCompletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoveryResult>;

    /**
     * Get information about a KEK recovery session
     * @summary Get KEK recovery session
     * @param {KEKApiKekRecoverySessionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApiInterface
     */
    kekRecoverySessionIdGet(requestParameters: KEKApiKekRecoverySessionIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession>;

    /**
     * Submit a share for KEK recovery
     * @summary Submit a recovery share
     * @param {KEKApiKekRecoverySessionIdSharesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApiInterface
     */
    kekRecoverySessionIdSharesPost(requestParameters: KEKApiKekRecoverySessionIdSharesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<KekRecoverySession>;

}

/**
 * Request parameters for kekRecoveryPost operation in KEKApi.
 * @export
 * @interface KEKApiKekRecoveryPostRequest
 */
export interface KEKApiKekRecoveryPostRequest {
    /**
     * 
     * @type {InitiateKEKRecoveryRequest}
     * @memberof KEKApiKekRecoveryPost
     */
    readonly initiateKEKRecoveryRequest: InitiateKEKRecoveryRequest
}

/**
 * Request parameters for kekRecoverySessionIdCompletePost operation in KEKApi.
 * @export
 * @interface KEKApiKekRecoverySessionIdCompletePostRequest
 */
export interface KEKApiKekRecoverySessionIdCompletePostRequest {
    /**
     * Recovery session ID
     * @type {string}
     * @memberof KEKApiKekRecoverySessionIdCompletePost
     */
    readonly sessionId: string

    /**
     * 
     * @type {CompleteKEKRecoveryRequest}
     * @memberof KEKApiKekRecoverySessionIdCompletePost
     */
    readonly completeKEKRecoveryRequest: CompleteKEKRecoveryRequest
}

/**
 * Request parameters for kekRecoverySessionIdGet operation in KEKApi.
 * @export
 * @interface KEKApiKekRecoverySessionIdGetRequest
 */
export interface KEKApiKekRecoverySessionIdGetRequest {
    /**
     * Recovery session ID
     * @type {string}
     * @memberof KEKApiKekRecoverySessionIdGet
     */
    readonly sessionId: string
}

/**
 * Request parameters for kekRecoverySessionIdSharesPost operation in KEKApi.
 * @export
 * @interface KEKApiKekRecoverySessionIdSharesPostRequest
 */
export interface KEKApiKekRecoverySessionIdSharesPostRequest {
    /**
     * Recovery session ID
     * @type {string}
     * @memberof KEKApiKekRecoverySessionIdSharesPost
     */
    readonly sessionId: string

    /**
     * 
     * @type {SubmitRecoveryShareRequest}
     * @memberof KEKApiKekRecoverySessionIdSharesPost
     */
    readonly submitRecoveryShareRequest: SubmitRecoveryShareRequest
}

/**
 * KEKApi - object-oriented interface
 * @export
 * @class KEKApi
 * @extends {BaseAPI}
 */
export class KEKApi extends BaseAPI implements KEKApiInterface {
    /**
     * Initiate the recovery of a KEK version
     * @summary Initiate KEK version recovery
     * @param {KEKApiKekRecoveryPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApi
     */
    public kekRecoveryPost(requestParameters: KEKApiKekRecoveryPostRequest, options?: RawAxiosRequestConfig) {
        return KEKApiFp(this.configuration).kekRecoveryPost(requestParameters.initiateKEKRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete the KEK recovery process
     * @summary Complete KEK recovery
     * @param {KEKApiKekRecoverySessionIdCompletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApi
     */
    public kekRecoverySessionIdCompletePost(requestParameters: KEKApiKekRecoverySessionIdCompletePostRequest, options?: RawAxiosRequestConfig) {
        return KEKApiFp(this.configuration).kekRecoverySessionIdCompletePost(requestParameters.sessionId, requestParameters.completeKEKRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about a KEK recovery session
     * @summary Get KEK recovery session
     * @param {KEKApiKekRecoverySessionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApi
     */
    public kekRecoverySessionIdGet(requestParameters: KEKApiKekRecoverySessionIdGetRequest, options?: RawAxiosRequestConfig) {
        return KEKApiFp(this.configuration).kekRecoverySessionIdGet(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a share for KEK recovery
     * @summary Submit a recovery share
     * @param {KEKApiKekRecoverySessionIdSharesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KEKApi
     */
    public kekRecoverySessionIdSharesPost(requestParameters: KEKApiKekRecoverySessionIdSharesPostRequest, options?: RawAxiosRequestConfig) {
        return KEKApiFp(this.configuration).kekRecoverySessionIdSharesPost(requestParameters.sessionId, requestParameters.submitRecoveryShareRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PublicKeysApi - axios parameter creator
 * @export
 */
export const PublicKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Revoke an existing public key
         * @summary Revoke a public key
         * @param {string} keyId Public key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysKeyIdDelete: async (keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('publicKeysKeyIdDelete', 'keyId', keyId)
            const localVarPath = `/public-keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing public key
         * @summary Update a public key
         * @param {string} keyId Public key ID
         * @param {UpdatePublicKeyRequest} updatePublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysKeyIdPut: async (keyId: string, updatePublicKeyRequest: UpdatePublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('publicKeysKeyIdPut', 'keyId', keyId)
            // verify required parameter 'updatePublicKeyRequest' is not null or undefined
            assertParamExists('publicKeysKeyIdPut', 'updatePublicKeyRequest', updatePublicKeyRequest)
            const localVarPath = `/public-keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new public key for a user
         * @summary Register a public key
         * @param {RegisterPublicKeyRequest} registerPublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysPost: async (registerPublicKeyRequest: RegisterPublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPublicKeyRequest' is not null or undefined
            assertParamExists('publicKeysPost', 'registerPublicKeyRequest', registerPublicKeyRequest)
            const localVarPath = `/public-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a public key for a specific user
         * @summary Get a user\'s public key
         * @param {string} userId User ID
         * @param {string} [purpose] Purpose of the public key (e.g., \&#39;admin-promotion\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysUserIdGet: async (userId: string, purpose?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('publicKeysUserIdGet', 'userId', userId)
            const localVarPath = `/public-keys/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify that a user owns a specific public key
         * @summary Verify ownership of a public key
         * @param {VerifyPublicKeyRequest} verifyPublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysVerifyPost: async (verifyPublicKeyRequest: VerifyPublicKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyPublicKeyRequest' is not null or undefined
            assertParamExists('publicKeysVerifyPost', 'verifyPublicKeyRequest', verifyPublicKeyRequest)
            const localVarPath = `/public-keys/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyPublicKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicKeysApi - functional programming interface
 * @export
 */
export const PublicKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Revoke an existing public key
         * @summary Revoke a public key
         * @param {string} keyId Public key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeysKeyIdDelete(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicKeysApi.publicKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing public key
         * @summary Update a public key
         * @param {string} keyId Public key ID
         * @param {UpdatePublicKeyRequest} updatePublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeysKeyIdPut(keyId: string, updatePublicKeyRequest: UpdatePublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeysKeyIdPut(keyId, updatePublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicKeysApi.publicKeysKeyIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new public key for a user
         * @summary Register a public key
         * @param {RegisterPublicKeyRequest} registerPublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeysPost(registerPublicKeyRequest: RegisterPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeysPost(registerPublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicKeysApi.publicKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a public key for a specific user
         * @summary Get a user\'s public key
         * @param {string} userId User ID
         * @param {string} [purpose] Purpose of the public key (e.g., \&#39;admin-promotion\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeysUserIdGet(userId: string, purpose?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeysUserIdGet(userId, purpose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicKeysApi.publicKeysUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify that a user owns a specific public key
         * @summary Verify ownership of a public key
         * @param {VerifyPublicKeyRequest} verifyPublicKeyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicKeysVerifyPost(verifyPublicKeyRequest: VerifyPublicKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyPublicKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicKeysVerifyPost(verifyPublicKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicKeysApi.publicKeysVerifyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicKeysApi - factory interface
 * @export
 */
export const PublicKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicKeysApiFp(configuration)
    return {
        /**
         * Revoke an existing public key
         * @summary Revoke a public key
         * @param {PublicKeysApiPublicKeysKeyIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysKeyIdDelete(requestParameters: PublicKeysApiPublicKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.publicKeysKeyIdDelete(requestParameters.keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing public key
         * @summary Update a public key
         * @param {PublicKeysApiPublicKeysKeyIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysKeyIdPut(requestParameters: PublicKeysApiPublicKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.publicKeysKeyIdPut(requestParameters.keyId, requestParameters.updatePublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new public key for a user
         * @summary Register a public key
         * @param {PublicKeysApiPublicKeysPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysPost(requestParameters: PublicKeysApiPublicKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.publicKeysPost(requestParameters.registerPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a public key for a specific user
         * @summary Get a user\'s public key
         * @param {PublicKeysApiPublicKeysUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysUserIdGet(requestParameters: PublicKeysApiPublicKeysUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey> {
            return localVarFp.publicKeysUserIdGet(requestParameters.userId, requestParameters.purpose, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify that a user owns a specific public key
         * @summary Verify ownership of a public key
         * @param {PublicKeysApiPublicKeysVerifyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicKeysVerifyPost(requestParameters: PublicKeysApiPublicKeysVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerifyPublicKeyResponse> {
            return localVarFp.publicKeysVerifyPost(requestParameters.verifyPublicKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicKeysApi - interface
 * @export
 * @interface PublicKeysApi
 */
export interface PublicKeysApiInterface {
    /**
     * Revoke an existing public key
     * @summary Revoke a public key
     * @param {PublicKeysApiPublicKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApiInterface
     */
    publicKeysKeyIdDelete(requestParameters: PublicKeysApiPublicKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Update an existing public key
     * @summary Update a public key
     * @param {PublicKeysApiPublicKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApiInterface
     */
    publicKeysKeyIdPut(requestParameters: PublicKeysApiPublicKeysKeyIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * Register a new public key for a user
     * @summary Register a public key
     * @param {PublicKeysApiPublicKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApiInterface
     */
    publicKeysPost(requestParameters: PublicKeysApiPublicKeysPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * Get a public key for a specific user
     * @summary Get a user\'s public key
     * @param {PublicKeysApiPublicKeysUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApiInterface
     */
    publicKeysUserIdGet(requestParameters: PublicKeysApiPublicKeysUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * Verify that a user owns a specific public key
     * @summary Verify ownership of a public key
     * @param {PublicKeysApiPublicKeysVerifyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApiInterface
     */
    publicKeysVerifyPost(requestParameters: PublicKeysApiPublicKeysVerifyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<VerifyPublicKeyResponse>;

}

/**
 * Request parameters for publicKeysKeyIdDelete operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiPublicKeysKeyIdDeleteRequest
 */
export interface PublicKeysApiPublicKeysKeyIdDeleteRequest {
    /**
     * Public key ID
     * @type {string}
     * @memberof PublicKeysApiPublicKeysKeyIdDelete
     */
    readonly keyId: string
}

/**
 * Request parameters for publicKeysKeyIdPut operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiPublicKeysKeyIdPutRequest
 */
export interface PublicKeysApiPublicKeysKeyIdPutRequest {
    /**
     * Public key ID
     * @type {string}
     * @memberof PublicKeysApiPublicKeysKeyIdPut
     */
    readonly keyId: string

    /**
     * 
     * @type {UpdatePublicKeyRequest}
     * @memberof PublicKeysApiPublicKeysKeyIdPut
     */
    readonly updatePublicKeyRequest: UpdatePublicKeyRequest
}

/**
 * Request parameters for publicKeysPost operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiPublicKeysPostRequest
 */
export interface PublicKeysApiPublicKeysPostRequest {
    /**
     * 
     * @type {RegisterPublicKeyRequest}
     * @memberof PublicKeysApiPublicKeysPost
     */
    readonly registerPublicKeyRequest: RegisterPublicKeyRequest
}

/**
 * Request parameters for publicKeysUserIdGet operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiPublicKeysUserIdGetRequest
 */
export interface PublicKeysApiPublicKeysUserIdGetRequest {
    /**
     * User ID
     * @type {string}
     * @memberof PublicKeysApiPublicKeysUserIdGet
     */
    readonly userId: string

    /**
     * Purpose of the public key (e.g., \&#39;admin-promotion\&#39;)
     * @type {string}
     * @memberof PublicKeysApiPublicKeysUserIdGet
     */
    readonly purpose?: string
}

/**
 * Request parameters for publicKeysVerifyPost operation in PublicKeysApi.
 * @export
 * @interface PublicKeysApiPublicKeysVerifyPostRequest
 */
export interface PublicKeysApiPublicKeysVerifyPostRequest {
    /**
     * 
     * @type {VerifyPublicKeyRequest}
     * @memberof PublicKeysApiPublicKeysVerifyPost
     */
    readonly verifyPublicKeyRequest: VerifyPublicKeyRequest
}

/**
 * PublicKeysApi - object-oriented interface
 * @export
 * @class PublicKeysApi
 * @extends {BaseAPI}
 */
export class PublicKeysApi extends BaseAPI implements PublicKeysApiInterface {
    /**
     * Revoke an existing public key
     * @summary Revoke a public key
     * @param {PublicKeysApiPublicKeysKeyIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public publicKeysKeyIdDelete(requestParameters: PublicKeysApiPublicKeysKeyIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).publicKeysKeyIdDelete(requestParameters.keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing public key
     * @summary Update a public key
     * @param {PublicKeysApiPublicKeysKeyIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public publicKeysKeyIdPut(requestParameters: PublicKeysApiPublicKeysKeyIdPutRequest, options?: RawAxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).publicKeysKeyIdPut(requestParameters.keyId, requestParameters.updatePublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new public key for a user
     * @summary Register a public key
     * @param {PublicKeysApiPublicKeysPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public publicKeysPost(requestParameters: PublicKeysApiPublicKeysPostRequest, options?: RawAxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).publicKeysPost(requestParameters.registerPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a public key for a specific user
     * @summary Get a user\'s public key
     * @param {PublicKeysApiPublicKeysUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public publicKeysUserIdGet(requestParameters: PublicKeysApiPublicKeysUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).publicKeysUserIdGet(requestParameters.userId, requestParameters.purpose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify that a user owns a specific public key
     * @summary Verify ownership of a public key
     * @param {PublicKeysApiPublicKeysVerifyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicKeysApi
     */
    public publicKeysVerifyPost(requestParameters: PublicKeysApiPublicKeysVerifyPostRequest, options?: RawAxiosRequestConfig) {
        return PublicKeysApiFp(this.configuration).publicKeysVerifyPost(requestParameters.verifyPublicKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



